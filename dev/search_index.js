var documenterSearchIndex = {"docs":
[{"location":"linear/#Linear-Tracking-Module","page":"Linear Tracking Module","title":"Linear Tracking Module","text":"","category":"section"},{"location":"misc/#Misc-Tracking-Submodule","page":"Misc Tracking Submodule","title":"Misc Tracking Submodule","text":"","category":"section"},{"location":"devel/#Developer's-Guide","page":"Developer's Guide","title":"Developer's Guide","text":"","category":"section"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"The design of BeamTracking.jl is built with modularity, high performance, differentiability, and polymorphism as key principles. Adding a new type of tracking method or lattice element should be simple.","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"The entire package is centered around one single track! function, which has the following format:","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"track!(beam::Beam, element, work=work)","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"Here, beam is a Beam struct, which is described in detail below. element is some element which to track the beam through, and work is an optional tuple of the minimal number of temporaries needed for use inside the tracking function (for some elements, it is an empty tuple). ","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"After calling track!, the beam struct is mutated to contain the particle phase space coordinates (and possiblly spin transport quaternions) after propagation through the element. With this track! function, all one needs to do is define their own custom element type, and then when looping through a vector of elements, Julia's multiple dispatch will take care of each particular element.","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"For example, using the Linear.Drift and Linear.Quadrupole elements:","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"d = Linear.Drift(L=0.2)\nqf = Linear.Quadrupole(B1=-18.5, L=0.5)\nqd = Linear.Quadrupole(B1=18.5, L=0.5)\n\nfodo = (qf, d, qd, d)\n\nbeam = Beam(x=1e-3, px=1e-4, pz=1e-4, beta_gamma_ref=35000.) # Creates a Beam with one particle\nfor ele in fodo\n  track!(beam, ele)\nend","category":"page"},{"location":"devel/#beam","page":"Developer's Guide","title":"The Beam Struct","text":"","category":"section"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"The Beam struct contains the following fields:","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"species::Species – A Species type storing the beam species (e.g. electron)\nbeta_gamma_ref::Float64   – A reference Lorentz betagamma for normalizing the transverse momenta to\nv::T – All particles' 6D phase space coordinates stored in a structure-of-arrays (SoA) memory layout\nq::U – If spin tracking, then all particles' spin transport quaternions (using the quaternion type defined in ReferenceFrameRotations.jl) stored in a structure-of-arrays layout. Else, nothing","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"If you are unfamiliar with structure-of-arrays (SoA) and array-of-structures (AoS), you should read this Wikipedia article.","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"This package extensively uses the StructArrays.jl, which features efficient and highly convenient implementation of structs for an SoA memory layout. A basic understanding of this package would be useful too.","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"In BeamTracking.jl, we define the Coord type which is a simple static vector of the 6D phase space coordinates:","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"# Static phase space coordinate vector\nBase.@kwdef struct Coord{T} <: FieldVector{6, T} \n  x::T  = 0.0\n  px::T = 0.0\n  y::T  = 0.0\n  py::T = 0.0\n  z::T  = 0.0\n  pz::T = 0.0\nend","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"Note that this is static and immutable, so you cannot change a field in Coord. Also note that a Vector{Coord{T}} is an AoS memory layout, and NOT SoA! StructArrays.jl makes it easy for us to use this type in a SoA layout, by simple using the StructArray type. For example,","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"N_particles = 1000\nx  = rand(N_particles)\npx = rand(N_particles)\ny  = rand(N_particles)\npy = rand(N_particles)\nz  = rand(N_particles)\npz = rand(N_particles)\n\nv = StructArray{Coord{Float64}}((x, px, y, py, z, pz))\nv.x  # accesses x array\nv.px # accesses px array\nv[1] # This goes from SoA to a single Coord struct representing the first Coord! ","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"In the above example, v is what is stored in the Beam struct. The choice of SoA was made after careful speed benchmarks and the desire to have a mutable interface (track! instead of track. for a beam).","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"When there spin tracking, q  is a StructArray{<:Quaternion}","category":"page"},{"location":"devel/#Rules-for-track!-Implementations","page":"Developer's Guide","title":"Rules for track! Implementations","text":"","category":"section"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"Vectorized operations should be used. The function should be type-stable and, when pre-allocating the necessary work, have zero allocations included when tracking a single non-parametric GTPSA map or tracking a beam of particles as immutable numbers (Float64 or Dual numbers for example). For parametric GTPSA maps (e.g. when a quadrupole strength is included as a parameter in the GTPSA), the allocation restriction is loosened in order to maintain readable code. Tests for this are included in the test_matrix function in runtests.jl","category":"page"},{"location":"devel/#Compatibility-with-GTPSA.jl","page":"Developer's Guide","title":"Compatibility with GTPSA.jl","text":"","category":"section"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"GTPSA.jl is a package which is used extensively in the SciBmad ecosystem for Taylor map tracking and normal form calculations. ","category":"page"},{"location":"devel/#Adding-a-dependency-to-a-submodule","page":"Developer's Guide","title":"Adding a dependency to a submodule","text":"","category":"section"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"If you would like to add a dependency to the project (e.g. OrdinaryDiffEq.jl), you should:","category":"page"},{"location":"devel/","page":"Developer's Guide","title":"Developer's Guide","text":"In the ~/.julia/dev/BeamTracking.jl directory, start julia\nEnter package-mode using ], and then type activate .. This activates the Project.toml in the current directory you're in\nIn package-mode, type add OrdinaryDiffEq. This will add the package as a dependency to the Project.toml.\nIn the main module src/BeamTracking.jl, add a using OrdinaryDiffEq to the top of BeamTracking.jl, and in your particularly module defined below add a using ..OrdinaryDiffEq which basically says, go one module level up and get OrdinaryDiffEq.","category":"page"},{"location":"#BeamTracking","page":"Home","title":"BeamTracking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BeamTracking.","category":"page"},{"location":"","page":"Home","title":"Home","text":"123","category":"page"},{"location":"matrixkick/#MatrixKick-Tracking-Submodule","page":"MatrixKick Tracking Submodule","title":"MatrixKick Tracking Submodule","text":"","category":"section"}]
}
